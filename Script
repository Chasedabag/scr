local Library = loadstring(game:HttpGet('https://raw.githubusercontent.com/Sepper2023/Scorp.xyz/refs/heads/main/LinoriaFixed'))()
local ThemeManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/Awakenchan/Misc-Release/main/linoracolor'))()
local SaveManager = loadstring(game:HttpGet('https://raw.githubusercontent.com/Sepper2023/Scorp.xyz/refs/heads/main/SaveManagerFixed'))()

-- Services
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Workspace = game:GetService("Workspace")
local Camera = Workspace.CurrentCamera

-- Variables
local LocalPlayer = Players.LocalPlayer
local AimEnabled = false -- Aimlock toggle
local AimlockKey = Enum.KeyCode.B -- Key to hold for aimlock
local FOV = 100 -- Field of View radius
local FOVThickness = 2 -- FOV Circle thickness
local FOVCircleVisible = true -- FOV visibility toggle
local Target = nil
local TargetBodyPart = nil
local lastCheckTime = 0 -- Time to control target search frequency
local targetSearchInterval = 0.1 -- Time in seconds
local smoothingSpeed = 0.8 -- Smoothing speed for gradual aiming (lower = slower)
local maxStepSize = 5 -- Maximum adjustment per frame (pixels)
local SnapLine = false -- Variable to toggle Snap Line visibility
local snapLineObject = nil -- To store the drawing object for Snap Line
local MaxDistance = 250 -- Max distance to show Snap Line (30 studs)
local VisibleCheckEnabled = false -- Enable/Disable visibility check

-- FOV Circle
local FOVCircle = Drawing.new("Circle")
FOVCircle.Visible = FOVCircleVisible
FOVCircle.Thickness = FOVThickness
FOVCircle.Color = Color3.fromRGB(0, 0, 0) -- Green
FOVCircle.Radius = FOV
FOVCircle.Filled = false

RunService.RenderStepped:Connect(function()
    FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
end)

-- Aimbot functions
local function IsTargetValid()
    return Target and Target.Character and Target.Character:FindFirstChild("Humanoid") and Target.Character.Humanoid.Health > 0
end

local function IsTargetVisible(player)
    local character = player.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        local head = character:FindFirstChild("Head")
        if head then
            local rootPartPosition = Camera:WorldToViewportPoint(rootPart.Position)
            local headPosition = Camera:WorldToViewportPoint(head.Position)
            
            local _, rootPartOnScreen = Camera:WorldToViewportPoint(rootPart.Position)
            local _, headOnScreen = Camera:WorldToViewportPoint(head.Position)

            return rootPartOnScreen and headOnScreen
        end
    end
    return false
end

local function GetClosestTarget()
    local closestPlayer = nil
    local shortestDistance = FOV
    local closestBodyPart = nil

    for _, player in pairs(Players:GetPlayers()) do
        if player == LocalPlayer or not player.Character then
            continue
        end

        local humanoid = player.Character:FindFirstChild("Humanoid")
        if not humanoid or humanoid.Health <= 0 then
            continue
        end

        if player.Team == LocalPlayer.Team then
            continue
        end

        -- Check if target is visible
        if VisibleCheckEnabled and not IsTargetVisible(player) then
            continue
        end

        local head = player.Character:FindFirstChild("Head")
        if head then
            local screenPosition, onScreen = Camera:WorldToViewportPoint(head.Position)
            if onScreen then
                local distance = (Vector2.new(screenPosition.X, screenPosition.Y) - Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)).Magnitude
                if distance < shortestDistance then
                    -- Calculate the distance to the target in studs
                    local distanceToPlayer = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude
                    -- Only consider targets within the MaxDistance
                    if distanceToPlayer <= MaxDistance then
                        shortestDistance = distance
                        closestPlayer = player
                        closestBodyPart = head
                    end
                end
            end
        end
    end

    return closestPlayer, closestBodyPart
end

local function GradualAim(Target, BodyPart, smoothingSpeed, maxStepSize)
    if Target and BodyPart then
        local bodyPartPosition = Camera:WorldToViewportPoint(BodyPart.Position)
        local targetMousePosition = Vector2.new(bodyPartPosition.X, bodyPartPosition.Y)
        local currentMousePosition = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

        local direction = targetMousePosition - currentMousePosition
        local smoothDeltaX = direction.X * smoothingSpeed
        local smoothDeltaY = direction.Y * smoothingSpeed

        -- Apply gradual smoothing with clamping to avoid excessive movements
        smoothDeltaX = math.clamp(smoothDeltaX, -maxStepSize, maxStepSize)
        smoothDeltaY = math.clamp(smoothDeltaY, -maxStepSize, maxStepSize)

        -- Move the mouse by a smooth delta, making it gradual
        mousemoverel(smoothDeltaX, smoothDeltaY)
    end
end

UserInputService.InputBegan:Connect(function(input)
    if input.KeyCode == AimlockKey then
        AimEnabled = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.KeyCode == AimlockKey then
        AimEnabled = false
        Target = nil
        -- Remove Snapline when aim is disabled
        if snapLineObject then
            snapLineObject.Visible = false
        end
    end
end)

RunService.RenderStepped:Connect(function()
    if AimEnabled then
        if not IsTargetValid() then
            if tick() - lastCheckTime >= targetSearchInterval then
                Target, TargetBodyPart = GetClosestTarget()
                lastCheckTime = tick()
            end
        end

        if Target and TargetBodyPart then
            GradualAim(Target, TargetBodyPart, smoothingSpeed, maxStepSize)

            -- Remove Snap Line when locked onto a target
            if snapLineObject then
                snapLineObject.Visible = false
            end
        end
    else
        -- Draw Snapline if enabled and no target locked
        if SnapLine then
            -- Get the closest target within FOV and distance check
            local closestPlayer, closestBodyPart = GetClosestTarget()

            -- Draw Snapline if there's a target in FOV and within the max distance
            if closestPlayer and closestBodyPart then
                local targetPosition = Camera:WorldToViewportPoint(closestBodyPart.Position)
                local centerPosition = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)

                -- If Snapline object doesn't exist, create one
                if not snapLineObject then
                    snapLineObject = Drawing.new("Line")
                    snapLineObject.Thickness = 2
                    snapLineObject.Color = Color3.fromRGB(255, 0, 0)  -- Red snapline
                    snapLineObject.Visible = false  -- Initially not visible
                end

                -- Only update the snap line when the position changes
                snapLineObject.From = centerPosition
                snapLineObject.To = Vector2.new(targetPosition.X, targetPosition.Y)
                snapLineObject.Visible = true  -- Make it visible when it's needed
            end
        end
    end
end)

-- Add to menu
local Window = Library:CreateWindow({ Title = "Aimbot Menu", Center = true, AutoShow = true })
local AimbotTab = Window:AddTab("Aimbot")
local VisualsTab = Window:AddTab("Visuals")
local SettingsTab = Window:AddTab("Settings")

local VisualsGroupBox = VisualsTab:AddLeftGroupbox("Settings")
local AimbotGroupBox = AimbotTab:AddLeftGroupbox("Settings")
local SettingsGroupBox = SettingsTab:AddLeftGroupbox("Settings")

-- Add FOV Toggle, Visible Check, and FOV Size & Thickness to Visuals Tab
VisualsGroupBox:AddToggle("FOVCircle", { Text = "Enable FOV Circle", Default = true }):OnChanged(function(state)
    FOVCircle.Visible = state
end)

VisualsGroupBox:AddSlider("FOVThickness", { Text = "FOV Circle Thickness", Default = 2, Min = 1, Max = 10, Rounding = 1 }):OnChanged(function(value)
    FOVCircle.Thickness = value
end)

VisualsGroupBox:AddSlider("FOVSize", { Text = "FOV Circle Size", Default = 0, Min = 0, Max = 200, Rounding = 1 }):OnChanged(function(value)
    FOV = value
    FOVCircle.Radius = value
end)

VisualsGroupBox:AddToggle("VisibleCheck", { Text = "Enable Visible Check", Default = false }):OnChanged(function(state)
    VisibleCheckEnabled = state
end)

VisualsGroupBox:AddToggle("Snap Line", { Text = "Snap Line", Default = false }):OnChanged(function(state)
    SnapLine = state
end)

-- Add Aimbot Toggle and Smoothness Slider
AimbotGroupBox:AddToggle("AimEnabled", { Text = "Enable Aimbot", Default = false }):OnChanged(function(state)
    AimEnabled = state
end)

AimbotGroupBox:AddSlider("Smoothness", { Text = "Aimbot Smoothness", Default = 0.8, Min = 0.1, Max = 1, Rounding = 2 }):OnChanged(function(value)
    smoothingSpeed = value
end)

-- Apply theme and save manager configurations
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)
SaveManager:Load()

-- Finalizing
Library:Init()

